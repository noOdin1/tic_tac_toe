    // let humanPlacement = false;
    // // human's turn
    // while (!humanPlacement) {
    //   await userInput.userKeyEntry();
    //   userEntry = userInput.getKeyEntry();
    //   console.log("[game] userEntry: " + userEntry);
    //   // if (userEntry in noOdin1sObjects.keyMap) {
    //   // }
    //   [x, y] = noOdin1sObjects.keyMap[userEntry];
    //
    //   if (game.getBoardPosition(x, y) == " ") {
    //     game.place("x", x, y);
    //     // game.printBoard();
    //     humanPlacement = true;
    //   } else {
    //     console.log("[game] That position is occupied.");
    //   }
    // }
    // game.printBoard();
    //
    // computersMove(compute, game, "o");
    // game.printBoard();
    //
    // game.checkForWinCondition();
    // if (userEntry == "r") {
    //   game.resetBoard();
    //   game.printBoard();
    // }


        // console.log(
        //   "\n[checkForWinCondition] 0 getBoardPosition(" +
        //     x0 +
        //     "," +
        //     y0 +
        //     ") = " +
        //     getBoardPosition(x0, y0),
        // );
        // console.log(
        //   "[checkForWinCondition] 1 getBoardPosition(" +
        //     x1 +
        //     "," +
        //     y1 +
        //     ") = " +
        //     getBoardPosition(x1, y1),
        // );
        // console.log(
        //   "[checkForWinCondition] 2 getBoardPosition(" +
        //     x2 +
        //     "," +
        //     y2 +
        //     ") = " +
        //     getBoardPosition(x2, y2),
        // );

// function userKeyPress() {
//   let keyEntry = 0;
//
//   /**
//    * NOTE: The method below was adopted after several tries with
//    *       using external functions and object. None was workable and
//    *       therefore this method was adopted. The source for this
//    *       solution:
//    *       https://stackoverflow.com/questions/17176046/pause-function-until-enter-key-is-pressed-javascript
//    *       Using an object to house the function, and let closure to return
//    *       the value captured from the keyboard.
//    */
//   function userKeyEntry() {
//     return new Promise((resolve) => {
//       document.addEventListener("keydown", onKeyHandler);
//       function onKeyHandler(event) {
//         if (event.key in keyMap || allowedKeys.indexOf(event.key) != -1) {
//           keyEntry = event.key;
//           document.removeEventListener("keydown", onKeyHandler);
//           resolve();
//         }
//       }
//     });
//   }
//
//   function getKeyEntry() {
//     return keyEntry;
//   }
//
//   return { getKeyEntry, userKeyEntry };
// }

// /**
//  * NOTE: This function works. It still has some short comings,
//  *         1. If all the spaces were filled up, then while() will
//  *            be an infinite loop;
//  *         2. The placements are random and no strategy added.
//
//  **/
// function computersMove(comp, game, mark) {
//   let placement = false;
//   // console.dir(game);
//   while (!placement) {
//     comp.getNewPos();
//     [x, y] = comp.getXYPos();
//     if (game.getBoardPosition(x, y) == " ") {
//       game.place(mark, x, y);
//       placement = true;
//     }
//   }
// }
//
// function humansMove(userEntry) {
//   let placement = false;
//   // human's turn
//   while (!placement) {
//     // await userInput.userKeyEntry();
//     // // await userKeyPress;
//     // userEntry = userInput.getKeyEntry();
//     console.log("[game] userEntry: " + userEntry);
//     if (userEntry in noOdin1sObjects.keyMap) {
//       [x, y] = noOdin1sObjects.keyMap[userEntry];
//
//       if (game.getBoardPosition(x, y) == " ") {
//         game.place("x", x, y);
//         // game.printBoard();
//         placement = true;
//       } else {
//         console.log("[game] That position is occupied.");
//       }
//     }
//   }
// }

      // console.table(keyMap);
      // let tmp = Object.keys(noOdin1sObjects.keyMap).find(function (key) {
      //   console.log(
      //     "key: " +
      //       key +
      //       ", keyMap[key]: " +
      //       keyMap[key] +
      //       ", [row, col]: " +
      //       [row, col],
      //   );
      //   if (noOdin1sObjects.keyMap[key] === [row, col]) {
      //     console.log("found it");
      //   }
      //   noOdin1sObjects.keyMap[key] == [row, col];
      // });

      console.log(
        "[reverseKeyLookup] typeof row: " +
          typeof row +
          ", typeof col: " +
          typeof col +
          ", typeof [row, col]: " +
          typeof [row, col],
      );
      console.log(
        "[reverseKeyLookup] typeof keyMap[0]: " +
          typeof noOdin1sObjects.keyMap[7],
      );
      let tempNum = new Array(row, col);
      console.log(
        "[reverseKeyLookup] noOdin1sObjects.keyMap[8][0]: " +
          noOdin1sObjects.keyMap[8][0] +
          ", noOdin1sObjects.keyMap[8[1]: " +
          noOdin1sObjects.keyMap[8][1],
      );
      // if (noOdin1sObjects.keyMap[7] === [row, col]) {
      if (noOdin1sObjects.keyMap[7] === [row, col]) {
        console.log("[reverseKeyLookup] Yes, they match");
      }

          let numKeyPadPos = Object.keys(noOdin1sObjects.keyMap).find(
            (key) => noOdin1sObjects.keyMap[key] === [i, j],
          );
          console.log("[round] numKeyPadPos: " + numKeyPadPos);
